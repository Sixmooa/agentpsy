<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äººæ ¼æµ‹è¯• - æµ‹è¯•å¥—ä»¶</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        
        .test-container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .test-header {
            background: linear-gradient(135deg, #3498db, #2c3e50);
            color: white;
            padding: 20px;
            border-radius: 8px 8px 0 0;
            margin: -30px -30px 20px -30px;
        }
        
        .test-section {
            margin-bottom: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        
        .test-case {
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 3px solid #28a745;
        }
        
        .test-case.failed {
            border-left-color: #dc3545;
            background: #fff5f5;
        }
        
        .test-result {
            font-weight: bold;
            margin-top: 10px;
        }
        
        .test-result.passed {
            color: #28a745;
        }
        
        .test-result.failed {
            color: #dc3545;
        }
        
        .run-tests-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
        }
        
        .run-tests-btn:hover {
            background: #2980b9;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .stat-item {
            background: #e9ecef;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            flex: 1;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .stat-label {
            font-size: 14px;
            color: #6c757d;
            margin-top: 5px;
        }
        
        .console-output {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>ğŸ§  äººæ ¼æµ‹è¯•ç³»ç»Ÿ - TDDæµ‹è¯•å¥—ä»¶</h1>
            <p>å…¨é¢æµ‹è¯•æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½æ¨¡å—ï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§å’Œå‡†ç¡®æ€§</p>
        </div>
        
        <div style="text-align: center; margin-bottom: 30px;">
            <button class="run-tests-btn" onclick="runAllTests()">ğŸš€ è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
        </div>
        
        <div class="stats" id="test-stats">
            <div class="stat-item">
                <div class="stat-value" id="total-tests">0</div>
                <div class="stat-label">æ€»æµ‹è¯•æ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="passed-tests">0</div>
                <div class="stat-label">é€šè¿‡</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="failed-tests">0</div>
                <div class="stat-label">å¤±è´¥</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="success-rate">0%</div>
                <div class="stat-label">æˆåŠŸç‡</div>
            </div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ“Š æ•°æ®éªŒè¯æµ‹è¯•</h2>
            <div id="data-tests"></div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ§® è®¡ç®—å™¨åŠŸèƒ½æµ‹è¯•</h2>
            <div id="calculator-tests"></div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ’¾ å­˜å‚¨ç®¡ç†æµ‹è¯•</h2>
            <div id="storage-tests"></div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ–¼ï¸ å›¾ç‰‡ç”Ÿæˆæµ‹è¯•</h2>
            <div id="image-tests"></div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ”§ é›†æˆæµ‹è¯•</h2>
            <div id="integration-tests"></div>
        </div>
        
        <div class="console-output" id="console-output"></div>
    </div>

    <!-- å¼•å…¥æ‰€æœ‰æ¨¡å— -->
    <script src="js/data.js"></script>
    <script src="js/calculator.js"></script>
    <script src="js/storage.js"></script>
    <script src="js/imageGenerator.js"></script>

    <script>
        // æµ‹è¯•æ¡†æ¶
        class TestFramework {
            constructor() {
                this.tests = [];
                this.results = [];
                this.currentSection = '';
            }

            describe(sectionName, testFn) {
                this.currentSection = sectionName;
                testFn();
            }

            test(description, testFn) {
                this.tests.push({
                    section: this.currentSection,
                    description,
                    testFn
                });
            }

            expect(actual) {
                return {
                    toBe: (expected) => {
                        if (actual !== expected) {
                            throw new Error(`Expected ${expected}, but got ${actual}`);
                        }
                        return true;
                    },
                    toEqual: (expected) => {
                        if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                            throw new Error(`Expected ${JSON.stringify(expected)}, but got ${JSON.stringify(actual)}`);
                        }
                        return true;
                    },
                    toBeGreaterThan: (expected) => {
                        if (actual <= expected) {
                            throw new Error(`Expected ${actual} to be greater than ${expected}`);
                        }
                        return true;
                    },
                    toBeTruthy: () => {
                        if (!actual) {
                            throw new Error(`Expected ${actual} to be truthy`);
                        }
                        return true;
                    },
                    toBeFalsy: () => {
                        if (actual) {
                            throw new Error(`Expected ${actual} to be falsy`);
                        }
                        return true;
                    },
                    toContain: (expected) => {
                        if (!actual.includes(expected)) {
                            throw new Error(`Expected ${actual} to contain ${expected}`);
                        }
                        return true;
                    },
                    toHaveLength: (expected) => {
                        if (actual.length !== expected) {
                            throw new Error(`Expected length ${expected}, but got ${actual.length}`);
                        }
                        return true;
                    },
                    toBeInstanceOf: (expected) => {
                        if (!(actual instanceof expected)) {
                            throw new Error(`Expected ${actual} to be instance of ${expected.name}`);
                        }
                        return true;
                    }
                };
            }

            async runTests() {
                this.results = [];
                const startTime = Date.now();

                for (const test of this.tests) {
                    try {
                        await test.testFn();
                        this.results.push({
                            ...test,
                            passed: true,
                            error: null
                        });
                        this.logToConsole(`âœ… ${test.description}`);
                    } catch (error) {
                        this.results.push({
                            ...test,
                            passed: false,
                            error: error.message
                        });
                        this.logToConsole(`âŒ ${test.description}: ${error.message}`);
                    }
                }

                const endTime = Date.now();
                const duration = endTime - startTime;

                this.displayResults();
                this.logToConsole(`\nğŸ æµ‹è¯•å®Œæˆï¼Œè€—æ—¶: ${duration}ms`);
            }

            displayResults() {
                const sections = ['data', 'calculator', 'storage', 'image', 'integration'];
                
                sections.forEach(section => {
                    const sectionTests = this.results.filter(r => r.section.toLowerCase().includes(section));
                    const container = document.getElementById(`${section}-tests`);
                    
                    if (container && sectionTests.length > 0) {
                        container.innerHTML = sectionTests.map(test => `
                            <div class="test-case ${test.passed ? 'passed' : 'failed'}">
                                <div>${test.description}</div>
                                <div class="test-result ${test.passed ? 'passed' : 'failed'}">
                                    ${test.passed ? 'âœ… é€šè¿‡' : 'âŒ å¤±è´¥'}
                                    ${test.error ? `: ${test.error}` : ''}
                                </div>
                            </div>
                        `).join('');
                    }
                });

                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                const total = this.results.length;
                const passed = this.results.filter(r => r.passed).length;
                const failed = total - passed;
                const successRate = total > 0 ? Math.round((passed / total) * 100) : 0;

                document.getElementById('total-tests').textContent = total;
                document.getElementById('passed-tests').textContent = passed;
                document.getElementById('failed-tests').textContent = failed;
                document.getElementById('success-rate').textContent = `${successRate}%`;
            }

            logToConsole(message) {
                const console = document.getElementById('console-output');
                console.textContent += message + '\n';
                console.scrollTop = console.scrollHeight;
            }
        }

        // åˆ›å»ºæµ‹è¯•å®ä¾‹
        const testFramework = new TestFramework();

        // æ•°æ®éªŒè¯æµ‹è¯•
        testFramework.describe('æ•°æ®éªŒè¯', () => {
            testFramework.test('é—®é¢˜æ•°æ®åº”è¯¥åŒ…å«50ä¸ªé—®é¢˜ï¼ˆä¸­æ–‡ï¼‰', () => {
                testFramework.expect(QUESTIONS_ZH).toHaveLength(50);
            });

            testFramework.test('é—®é¢˜æ•°æ®åº”è¯¥åŒ…å«50ä¸ªé—®é¢˜ï¼ˆè‹±æ–‡ï¼‰', () => {
                testFramework.expect(QUESTIONS_EN).toHaveLength(50);
            });

            testFramework.test('æ¯ä¸ªç»´åº¦åº”è¯¥æœ‰10ä¸ªé—®é¢˜', () => {
                const dimensions = ['openness', 'conscientiousness', 'extraversion', 'agreeableness', 'neuroticism'];
                dimensions.forEach(dimension => {
                    const count = QUESTIONS_ZH.filter(q => q.dimension === dimension).length;
                    testFramework.expect(count).toBe(10);
                });
            });

            testFramework.test('è´å°”å®¾è§’è‰²æ•°æ®åº”è¯¥å®Œæ•´', () => {
                testFramework.expect(Object.keys(BELBIN_ROLES)).toHaveLength(9);
                
                Object.values(BELBIN_ROLES).forEach(role => {
                    testFramework.expect(role.name).toBeTruthy();
                    testFramework.expect(role.description).toBeTruthy();
                    testFramework.expect(role.characteristics).toBeTruthy();
                });
            });

            testFramework.test('MBTIè¯¦æƒ…æ•°æ®åº”è¯¥åŒ…å«å¿…è¦ä¿¡æ¯', () => {
                const sampleTypes = ['INTJ-A', 'ENTP-T', 'ISFP-A'];
                sampleTypes.forEach(type => {
                    if (MBTI_DETAILS[type]) {
                        const details = MBTI_DETAILS[type];
                        testFramework.expect(details.name).toBeTruthy();
                        testFramework.expect(details.description).toBeTruthy();
                        testFramework.expect(details.strengths).toBeInstanceOf(Array);
                    }
                });
            });
        });

        // è®¡ç®—å™¨åŠŸèƒ½æµ‹è¯•
        testFramework.describe('è®¡ç®—å™¨åŠŸèƒ½', () => {
            let calculator;

            testFramework.test('PersonalityCalculatoråº”è¯¥èƒ½æ­£ç¡®å®ä¾‹åŒ–', () => {
                calculator = new PersonalityCalculator();
                testFramework.expect(calculator).toBeInstanceOf(PersonalityCalculator);
                testFramework.expect(calculator.midPoint).toBe(3.0);
            });

            testFramework.test('åº”è¯¥èƒ½æ­£ç¡®è®¡ç®—å¤§äº”äººæ ¼å¾—åˆ†', () => {
                const answers = {
                    1: 4, 2: 5, 3: 3, 4: 4, 5: 2,
                    6: 4, 7: 5, 8: 2, 9: 4, 10: 2
                };
                const questions = QUESTIONS_ZH.slice(0, 10);
                
                const scores = calculator.calculateBigFiveScores(answers, questions);
                
                testFramework.expect(typeof scores).toBe('object');
                testFramework.expect(scores.openness).toBeGreaterThan(0);
                testFramework.expect(scores.conscientiousness).toBeGreaterThan(0);
            });

            testFramework.test('åº”è¯¥èƒ½æ­£ç¡®è®¡ç®—MBTIç±»å‹', () => {
                const scores = {
                    openness: 4.2,
                    conscientiousness: 4.5,
                    extraversion: 2.8,
                    agreeableness: 3.9,
                    neuroticism: 2.1
                };
                
                const result = calculator.calculateMBTI(scores);
                
                testFramework.expect(result.type).toBeTruthy();
                testFramework.expect(result.typeCode).toBeTruthy();
                testFramework.expect(result.name).toBeTruthy();
                testFramework.expect(result.dimensions).toBeTruthy();
            });

            testFramework.test('åº”è¯¥èƒ½è·å–è´å°”å®¾è§’è‰²', () => {
                const roles = calculator.getBelbinRoles('INTJ');
                
                testFramework.expect(roles).toBeInstanceOf(Array);
                testFramework.expect(roles.length).toBeGreaterThan(0);
                testFramework.expect(roles[0].name).toBeTruthy();
            });

            testFramework.test('åº”è¯¥èƒ½éªŒè¯ç­”æ¡ˆå®Œæ•´æ€§', () => {
                const completeAnswers = {};
                const incompleteAnswers = { 1: 4, 2: 5 };
                
                // ç”Ÿæˆå®Œæ•´ç­”æ¡ˆ
                QUESTIONS_ZH.forEach(q => {
                    completeAnswers[q.id] = Math.floor(Math.random() * 5) + 1;
                });
                
                testFramework.expect(calculator.validateAnswers(completeAnswers, QUESTIONS_ZH)).toBeTruthy();
                testFramework.expect(calculator.validateAnswers(incompleteAnswers, QUESTIONS_ZH)).toBeFalsy();
            });

            testFramework.test('åº”è¯¥èƒ½æ­£ç¡®è®¡ç®—è¿›åº¦', () => {
                const answers = { 1: 4, 2: 5, 3: 3 };
                const progress = calculator.getProgress(answers, QUESTIONS_ZH.slice(0, 10));
                
                testFramework.expect(progress.answered).toBe(3);
                testFramework.expect(progress.total).toBe(10);
                testFramework.expect(progress.percentage).toBe(30);
                testFramework.expect(progress.isComplete).toBeFalsy();
            });
        });

        // å­˜å‚¨ç®¡ç†æµ‹è¯•
        testFramework.describe('å­˜å‚¨ç®¡ç†', () => {
            let storage;

            testFramework.test('StorageManageråº”è¯¥èƒ½æ­£ç¡®å®ä¾‹åŒ–', () => {
                storage = new StorageManager();
                testFramework.expect(storage).toBeInstanceOf(StorageManager);
                testFramework.expect(storage.storageKey).toBeTruthy();
            });

            testFramework.test('åº”è¯¥èƒ½æ£€æŸ¥å­˜å‚¨å¯ç”¨æ€§', () => {
                const isAvailable = storage.isStorageAvailable();
                testFramework.expect(typeof isAvailable).toBe('boolean');
            });

            testFramework.test('åº”è¯¥èƒ½ä¿å­˜å’Œè¯»å–æµ‹è¯•ç»“æœ', () => {
                const testResult = {
                    mbtiResult: { type: 'INTJ-A', name: 'å»ºç­‘å¸ˆ' },
                    bigFiveScores: { openness: 4.2, conscientiousness: 4.5 },
                    timestamp: new Date().toISOString()
                };

                // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
                storage.clearAllResults();
                
                const saved = storage.saveResult(testResult);
                if (storage.isStorageAvailable()) {
                    testFramework.expect(saved).toBeTruthy();
                    
                    const results = storage.getAllResults();
                    testFramework.expect(results).toBeInstanceOf(Array);
                    testFramework.expect(results.length).toBeGreaterThan(0);
                }
            });

            testFramework.test('åº”è¯¥èƒ½è·å–é»˜è®¤è®¾ç½®', () => {
                const settings = storage.getDefaultSettings();
                testFramework.expect(settings.language).toBeTruthy();
                testFramework.expect(settings.theme).toBeTruthy();
                testFramework.expect(typeof settings.autoSave).toBe('boolean');
            });

            testFramework.test('åº”è¯¥èƒ½ç”Ÿæˆå”¯ä¸€ID', () => {
                const id1 = storage.generateId();
                const id2 = storage.generateId();
                
                testFramework.expect(id1).toBeTruthy();
                testFramework.expect(id2).toBeTruthy();
                testFramework.expect(id1).not.toBe(id2);
            });
        });

        // å›¾ç‰‡ç”Ÿæˆæµ‹è¯•
        testFramework.describe('å›¾ç‰‡ç”Ÿæˆ', () => {
            let imageGenerator;

            testFramework.test('ImageGeneratoråº”è¯¥èƒ½æ­£ç¡®å®ä¾‹åŒ–', () => {
                // åˆ›å»ºcanvaså…ƒç´ 
                if (!document.getElementById('result-canvas')) {
                    const canvas = document.createElement('canvas');
                    canvas.id = 'result-canvas';
                    canvas.style.display = 'none';
                    document.body.appendChild(canvas);
                }

                imageGenerator = new ImageGenerator();
                testFramework.expect(imageGenerator).toBeInstanceOf(ImageGenerator);
                testFramework.expect(imageGenerator.canvas).toBeTruthy();
                testFramework.expect(imageGenerator.ctx).toBeTruthy();
            });

            testFramework.test('åº”è¯¥èƒ½è®¾ç½®æ­£ç¡®çš„ç”»å¸ƒå°ºå¯¸', () => {
                testFramework.expect(imageGenerator.width).toBe(800);
                testFramework.expect(imageGenerator.height).toBe(1200);
                testFramework.expect(imageGenerator.canvas.width).toBe(800);
                testFramework.expect(imageGenerator.canvas.height).toBe(1200);
            });

            testFramework.test('åº”è¯¥èƒ½æ¸…ç©ºç”»å¸ƒ', () => {
                imageGenerator.clearCanvas();
                // æµ‹è¯•ç”»å¸ƒæ˜¯å¦è¢«æ¸…ç©ºï¼ˆé€šè¿‡æ£€æŸ¥ç”»å¸ƒæ•°æ®ï¼‰
                const imageData = imageGenerator.ctx.getImageData(0, 0, 100, 100);
                const isEmpty = Array.from(imageData.data).every(value => value === 0);
                testFramework.expect(isEmpty).toBeTruthy();
            });

            testFramework.test('åº”è¯¥èƒ½ç”Ÿæˆæµ‹è¯•ç»“æœå›¾ç‰‡', () => {
                const mockResult = {
                    mbtiResult: {
                        typeCode: 'INTJ',
                        name: 'å»ºç­‘å¸ˆ',
                        nameEn: 'Architect',
                        description: 'å¯Œæœ‰æƒ³è±¡åŠ›å’Œæˆ˜ç•¥æ€§æ€æƒ³',
                        descriptionEn: 'Imaginative and strategic thinkers'
                    },
                    bigFiveScores: {
                        openness: 4.2,
                        conscientiousness: 4.5,
                        extraversion: 2.8,
                        agreeableness: 3.9,
                        neuroticism: 2.1
                    },
                    belbinRoles: [
                        {
                            name: 'æ™ºå¤šæ˜Ÿ',
                            nameEn: 'Plant',
                            description: 'å¯Œæœ‰æƒ³è±¡åŠ›å’Œåˆ›é€ åŠ›',
                            descriptionEn: 'Creative and imaginative'
                        }
                    ],
                    careerSuggestions: ['ç§‘å­¦å®¶', 'å·¥ç¨‹å¸ˆ', 'ç ”ç©¶å‘˜']
                };

                const imageData = imageGenerator.generateResultImage(mockResult, 'zh');
                testFramework.expect(imageData).toBeTruthy();
                testFramework.expect(imageData.startsWith('data:image/png;base64,')).toBeTruthy();
            });
        });

        // é›†æˆæµ‹è¯•
        testFramework.describe('é›†æˆæµ‹è¯•', () => {
            testFramework.test('åº”è¯¥èƒ½å®Œæ•´æ‰§è¡Œæµ‹è¯•æµç¨‹', () => {
                const calculator = new PersonalityCalculator();
                const storage = new StorageManager();
                
                // ç”Ÿæˆæ¨¡æ‹Ÿç­”æ¡ˆ
                const answers = {};
                QUESTIONS_ZH.forEach(q => {
                    answers[q.id] = Math.floor(Math.random() * 5) + 1;
                });

                // ç”ŸæˆæŠ¥å‘Š
                const report = calculator.generateReport(answers, QUESTIONS_ZH, 'zh');
                
                testFramework.expect(report.bigFiveScores).toBeTruthy();
                testFramework.expect(report.mbtiResult).toBeTruthy();
                testFramework.expect(report.belbinRoles).toBeInstanceOf(Array);
                testFramework.expect(report.careerSuggestions).toBeInstanceOf(Array);
                testFramework.expect(report.timestamp).toBeTruthy();
                testFramework.expect(report.language).toBe('zh');

                // ä¿å­˜ç»“æœ
                if (storage.isStorageAvailable()) {
                    const saved = storage.saveResult(report);
                    testFramework.expect(saved).toBeTruthy();
                }
            });

            testFramework.test('åº”è¯¥èƒ½å¤„ç†è¾¹ç•Œæƒ…å†µ', () => {
                const calculator = new PersonalityCalculator();
                
                // æµ‹è¯•æç«¯å¾—åˆ†
                const extremeScores = {
                    openness: 5.0,
                    conscientiousness: 1.0,
                    extraversion: 5.0,
                    agreeableness: 1.0,
                    neuroticism: 5.0
                };
                
                const result = calculator.calculateMBTI(extremeScores);
                testFramework.expect(result.type).toBeTruthy();
                testFramework.expect(result.typeCode).toBeTruthy();
                
                // æµ‹è¯•ç©ºç­”æ¡ˆ
                const progress = calculator.getProgress({}, QUESTIONS_ZH);
                testFramework.expect(progress.answered).toBe(0);
                testFramework.expect(progress.percentage).toBe(0);
                testFramework.expect(progress.isComplete).toBeFalsy();
            });

            testFramework.test('åº”è¯¥èƒ½å¤„ç†å¤šè¯­è¨€åˆ‡æ¢', () => {
                const calculator = new PersonalityCalculator();
                
                // ç”Ÿæˆç­”æ¡ˆ
                const answers = {};
                QUESTIONS_ZH.forEach(q => {
                    answers[q.id] = Math.floor(Math.random() * 5) + 1;
                });

                // æµ‹è¯•ä¸­æ–‡æŠ¥å‘Š
                const reportZh = calculator.generateReport(answers, QUESTIONS_ZH, 'zh');
                testFramework.expect(reportZh.language).toBe('zh');
                
                // æµ‹è¯•è‹±æ–‡æŠ¥å‘Š
                const reportEn = calculator.generateReport(answers, QUESTIONS_EN, 'en');
                testFramework.expect(reportEn.language).toBe('en');
                
                // ç»“æœåº”è¯¥ä¸€è‡´ï¼ˆé™¤äº†è¯­è¨€ï¼‰
                testFramework.expect(reportZh.mbtiResult.typeCode).toBe(reportEn.mbtiResult.typeCode);
            });

            testFramework.test('åº”è¯¥èƒ½å¤„ç†æ•°æ®å¯¼å…¥å¯¼å‡º', () => {
                const storage = new StorageManager();
                
                if (!storage.isStorageAvailable()) {
                    return; // è·³è¿‡æ­¤æµ‹è¯•å¦‚æœå­˜å‚¨ä¸å¯ç”¨
                }

                // æ¸…ç©ºå¹¶æ·»åŠ æµ‹è¯•æ•°æ®
                storage.clearAllResults();
                const testData = {
                    mbtiResult: { type: 'ENFP-T' },
                    bigFiveScores: { openness: 4.0 },
                    timestamp: new Date().toISOString()
                };
                
                storage.saveResult(testData);
                
                // å¯¼å‡ºæ•°æ®
                const exportedData = storage.exportData();
                testFramework.expect(exportedData).toBeTruthy();
                testFramework.expect(exportedData.includes('ENFP-T')).toBeTruthy();
                
                // æ¸…ç©ºå¹¶å¯¼å…¥æ•°æ®
                storage.clearAllResults();
                const imported = storage.importData(exportedData);
                testFramework.expect(imported).toBeTruthy();
                
                const results = storage.getAllResults();
                testFramework.expect(results.length).toBeGreaterThan(0);
            });
        });

        // è¿è¡Œæ‰€æœ‰æµ‹è¯•çš„å‡½æ•°
        async function runAllTests() {
            const button = document.querySelector('.run-tests-btn');
            button.disabled = true;
            button.textContent = 'ğŸ”„ è¿è¡Œä¸­...';
            
            // æ¸…ç©ºæ§åˆ¶å°è¾“å‡º
            document.getElementById('console-output').textContent = '';
            
            testFramework.logToConsole('ğŸš€ å¼€å§‹è¿è¡Œæµ‹è¯•å¥—ä»¶...\n');
            
            try {
                await testFramework.runTests();
            } catch (error) {
                testFramework.logToConsole(`âŒ æµ‹è¯•è¿è¡Œå¤±è´¥: ${error.message}`);
            } finally {
                button.disabled = false;
                button.textContent = 'ğŸš€ è¿è¡Œæ‰€æœ‰æµ‹è¯•';
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨è¿è¡Œæµ‹è¯•
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                runAllTests();
            }, 1000);
        });
    </script>
</body>
</html>